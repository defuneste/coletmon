---
title: "Exploration Relation Col&Mon"
author: "Olivier"
date: "17 octobre 2019"
output: 
    bookdown::html_document2:
        theme: readable
        toc: true
        toc_float: true
        number_sections: true
        fig_caption: yes
        code_folding: hide
    
---

```{r setup, include = FALSE}
library(dplyr) # manip données
```


# Statistiques descriptives des données

## Chargement des données et prise en main

### Chargement 

```{r chargement}
implantation.dat <- readRDS("data/T0impl.Rds")
fait.dat <- readRDS("data/T0New.Rds")
# une exraction des relations
relation.dat <- fait.dat[fait.dat$caracNew == "Relations" ,]
```

Les données sont regroupées en deux tableaux :

* "T0impl.Rds" contenant les implantations,
* "T0New.Rds" contenant les faits.

C'est du second que l'on tire les relations.

### Prise en main

```{r bon encoding}
# l'encoding semble en UTF8 et latin1 en fonction des colonnes/sources de la données
# la fonction Encoding permet de le specifier
Encoding(fait.dat$usual_name) <- "latin1"
Encoding(fait.dat$caracteristique) <- "latin1"
Encoding(fait.dat$linked_implantation_name) <- "latin1"
```

Il faut specifier les encoding de 3 colonnes qui sont en "Latin1" alors que le reste semble être en UTF8


Le tableau \@ref(tab:presenceNa) reprend les nombre de données manquantes par variables. L'absence la plus importante est sur les dates (210 et 206 manquantes), puis sur la localisation  (72 NA) avec lat/long et granularité et sur les diocése (11 NA). 

```{r, presenceNa, results="asis" }
relation_na.dat <- as.data.frame(apply(relation.dat, 2, function(x)length(x[is.na(x)])))
names(relation_na.dat) <- "Nbr_NA"
relation_na.dat$variables <- rownames(relation_na.dat)
rownames(relation_na.dat) <- NULL

cat("<tableau>",paste0("<caption>", "(#tab:presenceNa)", ' Nombre de données manquantes par variabes', "</caption>"),"</tableau>", sep ="\n")

DT::datatable(relation_na.dat)
#knitr::kable(apply(relation.dat, 2, function(x)length(x[is.na(x)])))
```


## Description des relations

### Modalité des relations

On obtient `r nrow(relation.dat)` factoides avec une `relation`. Le tableau \@ref(tab:modalite) répartit `modalite` en fonction des `modAgreg`. `H` de `modAgreg` ne correspond qu'aux associations de prière (`r nrow(relation.dat[relation.dat$modalite == "Association de prière",])`)) et `X` ne correspond qu'aux déplacements d'institution (`r nrow(relation.dat[relation.dat$modalite == "Déplacement d'institution",])`). `A` et `D` correspondent aux relations ascendantes et descendantes comprises entre trois couples : 

* `À la collation de / Droit de patronage`, 
* `Appartient / à Possède` et 
* `Filiation ascendante directe / Filiation descendante`.

(ref:modalite-caption) Ventilation de modAgreg en fonction de modalite

```{r, modalite}
knitr::kable(t(table(relation.dat$modAgreg, relation.dat$modalite)),
             caption = "(ref:modalite-caption)")
```

### Modalités de relations dans le temps




# Premiers graphes sur les relations

## En prenant le tout 

```{r premier_graph, message=FALSE}
library(igraph)
relation <- relation.dat[relation.dat$modAgreg != "A",] # on enleve les doublons
# on ne garde que les noms
relation <- subset(relation, select =  c("usual_name", "linked_implantation_name"))
# objet de graphs
graph_ensemble <- graph.edgelist(as.matrix(relation), directed = FALSE)
```

Attention `igraph` masque et utilise des fonctions de `dplyr` et `base` comme `as_data_frame`, `groups`, `union`.

On obtient un graphe peut lisible avec `r gsize(graph_ensemble)` liens et `r gorder(graph_ensemble)` noeuds.

