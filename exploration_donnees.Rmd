---
title: "Exploration Relation Col&Mon"
author: "Olivier"
date: "17 octobre 2019"
output: 
    bookdown::html_document2:
        theme: readable
        toc: true
        toc_float: true
        number_sections: true
        fig_caption: yes
        code_folding: hide
    
---

```{r setup, include = FALSE}
library(dplyr) # manip données
library(ggplot2) #  graphiques
library(plotly) # graphiques un peu interactif
```


# Statistiques descriptives des données

## Chargement des données et prise en main

### Chargement 

```{r chargement}
#implantation.dat <- readRDS("data/T0impl.Rds")
# fait.dat <- readRDS("data/T0New.Rds")
fait.dat <- read.csv("data/fait.txt", stringsAsFactors = FALSE) # besoin d'ajouter cela sinon il me garde tous les niveaux des facteurs
implantation.dat <- read.csv("data/implantation.txt")
# une exraction des relations
relation.dat <- fait.dat[fait.dat$caracNew == "Relations" ,]
```

Les données sont regroupées en deux tableaux :

* "T0impl.Rds" contenant les implantations,
* "T0New.Rds" contenant les faits.

C'est du second que l'on tire les relations.

### Prise en main

```{r bon encoding}
# l'encoding semble en UTF8 et latin1 en fonction des colonnes/sources de la données
# la fonction Encoding permet de le specifier
# Encoding(fait.dat$usual_name) <- "latin1"
# Encoding(fait.dat$caracteristique) <- "latin1"
# Encoding(fait.dat$linked_implantation_name) <- "latin1"
```

Il faut specifier les encoding de 3 colonnes qui sont en "Latin1" alors que le reste semble être en UTF8. Au final knitr semble avoir un problème avec du "multi encoding", j'ai donc fait un export/import le tout en UTF8.


Le tableau \@ref(tab:presenceNa) reprend les nombre de données manquantes par variables. L'absence la plus importante est sur les dates (210 et 206 manquantes), puis sur la localisation  (72 NA) avec lat/long et granularité et sur les diocése (11 NA). 

```{r, presenceNa, results="asis" }
# un apply, passer en df qui compte le nombre de NA par colonne 
relation_na.dat <- as.data.frame(apply(relation.dat, 2, function(x)length(x[is.na(x)])))
names(relation_na.dat) <- "Nbr_NA" # on renome puis on fait une deuxième var qui prend les rowname
relation_na.dat$variables <- rownames(relation_na.dat)
rownames(relation_na.dat) <- NULL

# une bidouille pour avoir un titre de tableau avec ref
cat("<tableau>",paste0("<caption>", "(#tab:presenceNa)", ' Nombre de données manquantes par variabes', "</caption>"),"</tableau>", sep ="\n")

DT::datatable(relation_na.dat) 
#knitr::kable(apply(relation.dat, 2, function(x)length(x[is.na(x)]))) # la version à l'arrache knitr
```


## Description des relations

### Modalité des relations

On obtient `r nrow(relation.dat)` factoides avec une `relation`. Le tableau \@ref(tab:modalite) répartit `modalite` en fonction des `modAgreg`. `H` de `modAgreg` ne correspond qu'aux associations de prière (`r nrow(relation.dat[relation.dat$modalite == "Association de prière",])`)) et `X` ne correspond qu'aux déplacements d'institution (`r nrow(relation.dat[relation.dat$modalite == "Déplacement d'institution",])`). `A` et `D` correspondent aux relations ascendantes et descendantes comprises entre trois couples : 

* `À la collation de / Droit de patronage`, 
* `Appartient / à Possède` et 
* `Filiation ascendante directe / Filiation descendante`.

(ref:modalite-caption) Ventilation de modAgreg en fonction de modalite

```{r, modalite}
knitr::kable(t(table(relation.dat$modAgreg, relation.dat$modalite)),
             caption = "(ref:modalite-caption)")
```

### Modalités et relations dans le temps

#### Exploration des données manquantes dans les dates 

Il y a 210 et 206 valeurs manquantes au niveau des dates (cf. tableau \@ref(tab:presenceNa)). Ces valeurs manquantes sont consistantes dans les 6 champs de de description des dates : une absence de donnée en `date_start_XX` se retrouve en `date_stop_XX` et donc dans la fourchette produite.

Il y a cependant 4 exceptions, où l'on a une `date_stop`, correspondant à deux couples A/D : 

```{r}
NA_date <- relation.dat[is.na(relation.dat$date_start_min),]
knitr::kable(NA_date[!is.na(NA_date$date_stop_max),c(2:4,7,13)]) # attention ici une indexation sur num de colonnes
```

En regardant la répartition des valeurs manquantes temporelles en fonction de `modalite` (\@ref(tab:Namodalite)) on peut remarquer qu'un couple A/D n'est pas complet (60/61). 

(ref:Namodalite-caption) Répartition des NA temporelles dans les modalite

```{r, Namodalite}
knitr::kable(table(NA_date$modalite), caption = "(ref:Namodalite-caption)")
```

Il me semble que c'est ce couple, Hélene peux tu regarder ? Je rajoute les valeurs ?

```{r}
rbind(NA_date[NA_date$modAgreg == "D",][76,],
relation.dat[relation.dat$idimplantation == 2483,]) # attention c'est une indexation par rapport à un emplacement 
```

On peut produire une carte rapide des valeurs manquantes pour les dates (promis j'en fait une belle semi-interactive sous mapview plus tard, je suis allez au plus vite ce vendredi après midi). On en a un gros cluster autour de la region lyonaise et un autre autour de Charleville-Mézières. Est ce que cela suit une logique par rapport au données ? 


```{r, include= F}
source("fonctions_carto.R") # on charge des fonctions de carto
library(sf)
# on passe implantation en sf
implantation.shp <- st_as_sf(implantation.dat[!is.na(implantation.dat$lat),], coords = c("lng", "lat"), crs = 4326)
# de wgs 84 au lambert 93
implantation.shp <- st_transform(implantation.shp, 2154) 
NA_date.shp <- st_sf(left_join(NA_date, implantation.shp, by = "idimplantation"))
diocese.shp <- diocese() # on charge les dioceses
```


```{r, carte_Na_date, message = FALSE}
plot(st_geometry(diocese.shp))
plot(st_geometry(implantation.shp), add =  T, col = "lightgrey", pch = 16, cex = .5)
plot(st_geometry(NA_date.shp), add = T, col = "red", pch = 16, cex = .5)
legend("topleft", legend=c("Avec dates", "Sans date"), pch = 16,
       col=c("lightgrey", "red"))
```

#### Dates et durées

Il n'y a que trois cas d'ecarts importants entre `date_start_min` et `date_start_man` representé par la figure (\@ref(fig:verif-datemin-et-max)). Les données ignorées sont les NA.

(ref:verif-datemin-et-max) Ecarts entre date_start_min et date_start_max

```{r, verif-datemin-et-max, message = FALSE, fig.cap="(ref:verif-datemin-et-max)"}
# c'est du js
f <- list(
  family = "Courier New, monospace",
  size = 18,
  color = "#7f7f7f"
)
x <- list(
  title = "date_start_min",
  titlefont = f
)
y <- list(
  title = "date_start_max",
  titlefont = f
)
# j'enleve les doublons A/D
relation_sans_A.dat <- relation.dat[relation.dat$modAgreg != "A",]
# il ignore les NA
plot_ly(relation_sans_A.dat, x = relation_sans_A.dat$date_start_min, y = relation_sans_A.dat$date_start_max, type="scatter", # on def X et y
        # on fait un text
        text = paste(relation_sans_A.dat$usual_name, relation_sans_A.dat$modalite, relation_sans_A.dat$linked_implantation, sep = "\n")) %>% 
layout(xaxis = x, yaxis = y)
```


# Premiers graphes sur les relations

## En prenant le tout 

```{r premier_graph, message=FALSE}
library(igraph)
relation <- relation.dat[relation.dat$modAgreg != "A",] # on enleve les doublons
# on ne garde que les noms
relation <- subset(relation, select =  c("usual_name", "linked_implantation_name"))
# objet de graphs
graph_ensemble <- graph.edgelist(as.matrix(relation), directed = FALSE)
```

Attention `igraph` masque et utilise des fonctions de `dplyr` et `base` comme `as_data_frame`, `groups`, `union`.

On obtient un graphe peut lisible avec `r gsize(graph_ensemble)` liens et `r gorder(graph_ensemble)` noeuds.

