---
title: "Statistiques descriptives des données relations col&mon"
author: "Olivier"
date: "17 octobre 2019"
output: 
    bookdown::html_document2:
        theme: readable
        toc: true
        toc_float: true
        number_sections: true
        fig_caption: yes
        code_folding: hide
    
---

```{r setup, include = FALSE}
library(tidyr)
library(dplyr) # manip données
library(ggplot2) #  graphiques
library(plotly) # graphiques un peu interactif
```




# Chargement des données et prise en main

## Chargement 

```{r chargement}
#implantation.dat <- readRDS("data/T0impl.Rds")
# fait.dat <- readRDS("data/T0New.Rds")
fait.dat <- read.csv("data/fait.txt", stringsAsFactors = FALSE) # besoin d'ajouter cela sinon il me garde tous les niveaux des facteurs
implantation.dat <- read.csv("data/implantation.txt")
# une exraction des relations
relation.dat <- fait.dat[fait.dat$caracNew == "Relations" ,]
```

Les données sont regroupées en deux tableaux :

* "T0impl.Rds" contenant les implantations,
* "T0New.Rds" contenant les faits.

C'est du second que l'on tire les relations.

## Prise en main

```{r bon encoding}
# l'encoding semble en UTF8 et latin1 en fonction des colonnes/sources de la données
# la fonction Encoding permet de le specifier
# Encoding(fait.dat$usual_name) <- "latin1"
# Encoding(fait.dat$caracteristique) <- "latin1"
# Encoding(fait.dat$linked_implantation_name) <- "latin1"
```

Il faut specifier les encoding de 3 colonnes qui sont en "Latin1" alors que le reste semble être en UTF8. Au final knitr semble avoir un problème avec du "multi encoding", j'ai donc fait un export/import le tout en UTF8.


Le tableau \@ref(tab:presenceNa) reprend les nombre de données manquantes par variables. L'absence la plus importante est sur les dates (210 et 206 manquantes), puis sur la localisation  (72 NA) avec lat/long et granularité et sur les diocése (11 NA). 

```{r, presenceNa, results="asis" }
# un apply, passer en df qui compte le nombre de NA par colonne 
relation_na.dat <- as.data.frame(apply(relation.dat, 2, function(x)length(x[is.na(x)])))
names(relation_na.dat) <- "Nbr_NA" # on renome puis on fait une deuxième var qui prend les rowname
relation_na.dat$variables <- rownames(relation_na.dat)
rownames(relation_na.dat) <- NULL

# une bidouille pour avoir un titre de tableau avec ref
cat("<tableau>",paste0("<caption>", "(#tab:presenceNa)", ' Nombre de données manquantes par variabes', "</caption>"),"</tableau>", sep ="\n")

DT::datatable(relation_na.dat) 
#knitr::kable(apply(relation.dat, 2, function(x)length(x[is.na(x)]))) # la version à l'arrache knitr
```


# Description des relations

## Modalité des relations

On obtient `r nrow(relation.dat)` factoides avec une `relation`. Le tableau \@ref(tab:modalite) répartit `modalite` en fonction des `modAgreg`. `H` de `modAgreg` ne correspond qu'aux associations de prière (`r nrow(relation.dat[relation.dat$modalite == "Association de prière",])`) et `X` ne correspond qu'aux déplacements d'institution (`r nrow(relation.dat[relation.dat$modalite == "Déplacement d'institution",])`). `A` et `D` correspondent aux relations ascendantes et descendantes comprises entre trois couples : 

* `À la collation de / Droit de patronage`, 
* `Appartient / à Possède` et 
* `Filiation ascendante directe / Filiation descendante`.

(ref:modalite-caption) Ventilation de modAgreg en fonction de modalite

```{r, modalite}
knitr::kable(t(table(relation.dat$modAgreg, relation.dat$modalite)),
             caption = "(ref:modalite-caption)")
```

## Modalités et relations dans le temps

### Exploration des données manquantes dans les dates 

Il y a 210 et 206 valeurs manquantes au niveau des dates (cf. tableau \@ref(tab:presenceNa)). Ces valeurs manquantes sont consistantes dans les 6 champs de de description des dates : une absence de donnée en `date_start_XX` se retrouve en `date_stop_XX` et donc dans la fourchette produite.

Il y a cependant 4 exceptions, où l'on a une `date_stop`, correspondant à deux couples A/D : 

```{r}
NA_date <- relation.dat[is.na(relation.dat$date_start_min),]
knitr::kable(NA_date[!is.na(NA_date$date_stop_max),c(2:4,7,13)]) # attention ici une indexation sur num de colonnes
```

En regardant la répartition des valeurs manquantes temporelles en fonction de `modalite` (\@ref(tab:Namodalite)) on peut remarquer qu'un couple A/D n'est pas complet (60/61). 

(ref:Namodalite-caption) Répartition des NA temporelles dans les modalite

```{r, Namodalite}
knitr::kable(table(NA_date$modalite), caption = "(ref:Namodalite-caption)")
```

Il me semble que c'est ce couple, Hélene peux tu regarder ? Je rajoute les valeurs ?

```{r}
rbind(NA_date[NA_date$modAgreg == "D",][76,],
relation.dat[relation.dat$idimplantation == 2483,]) # attention c'est une indexation par rapport à un emplacement 
```

On peut produire une carte rapide des valeurs manquantes pour les dates. On en a un gros cluster autour de la region lyonaise et un autre autour de Charleville-Mézières. Est ce que cela suit une logique par rapport au données ? 


```{r, include= F}
source("fonctions_carto.R") # on charge des fonctions de carto
library(sf)
# on passe implantation en sf
implantation.shp <- st_as_sf(implantation.dat[!is.na(implantation.dat$lat),], coords = c("lng", "lat"), crs = 4326)
# de wgs 84 au lambert 93
implantation.shp <- st_transform(implantation.shp, 2154) 
NA_date.shp <- st_sf(left_join(NA_date, implantation.shp, by = "idimplantation"))
diocese.shp <- diocese() # on charge les dioceses
```


```{r, carte_Na_date, message = FALSE, fig.align='center'}
plot(st_geometry(diocese.shp))
plot(st_geometry(implantation.shp), add =  T, col = "lightgrey", pch = 16, cex = .5)
plot(st_geometry(NA_date.shp), add = T, col = "red", pch = 16, cex = .5)
legend("topleft", legend=c("Avec dates", "Sans date"), pch = 16,
       col=c("lightgrey", "red"))
```

Et voici une interactive sous `mapview` : (il y a deux relations qui ne trouve pas d'implantations est ce possible ?)

```{r, message = FALSE, fig.align='center'}
initmapview()
mapview::mapview(diocese.shp, color = "gray75",  lwd = 1, # couleur et type du contour
                     col.regions = "red",  alpha = 0.5,                  # couleur du fond et type
                     layer.name = "Diocèses" ) +
mapview::mapview(implantation.shp, cex = 0.1, layer.name = "Implantations") +
mapview::mapview(NA_date.shp, zcol = "modAgreg", layer.name = "Relations sans dates")
```


### Dates et durées pour les relations

Je n'ai pas gardé les relations ascendantes pour les analyses suivantes car elles sont identiques. 

Les durées sont produites à partir des fourchettes de dates de début et de fin (`date_start_min/max` et `date_stop_min/max`). Il n'y a que trois cas d'ecarts importants entre `date_start_min` et `date_start_max` representé par la figure \@ref(fig:verif-datemin-et-max). Les données manquantes ne sont pas prises en compte. `date_stop_min` et `date_stop_max` sont identiques pour les relations.

(ref:verif-datemin-et-max) Ecarts entre date_start_min et date_start_max

```{r, verif-datemin-et-max, message = FALSE, fig.cap="(ref:verif-datemin-et-max)", fig.align='center'}
# c'est du js
f <- list(
  family = "Courier New, monospace",
  size = 18,
  color = "#7f7f7f"
)
x <- list(
  title = "date_start_min",
  titlefont = f
)
y <- list(
  title = "date_start_max",
  titlefont = f
)
# j'enleve les doublons A/D et NA
relation_sans_A.dat <- relation.dat[relation.dat$modAgreg != "A",]
relation_sans_A.dat <- relation_sans_A.dat[!is.na(relation_sans_A.dat$date_startC),]
# il ignore les NA
plot_ly(relation_sans_A.dat, x = relation_sans_A.dat$date_start_min, y = relation_sans_A.dat$date_start_max, type="scatter", # on def X et y
        # on fait un text
        text = paste(relation_sans_A.dat$usual_name, relation_sans_A.dat$modalite, relation_sans_A.dat$linked_implantation, sep = "\n")) %>% 
layout(xaxis = x, yaxis = y)
```

La figure \@ref(fig:date-modalite) regroupe les répartitions des dates (par tranches de 50 ans) de debut et fin des modes d'agrégations. Avec ce grain, assez grossier, on peut noter un premier pic dans les dates de relation autour 1100 pour les relations A/D (penser à detailler cette agrégation), suivit d'un second pic de debut de relation autour de 1300 qui n'est rattrapé en fin de relation qu'en 1750-1800. Il y a deux pics de dates de début/fin pour les associations de prières (`H`) le premier autour de 1250-1300 et le second autour de 1400 pour le debut puis 1450 pour la fin. 

(ref:date-modalite) Répartition des dates (début/fin) par tranches de 50 ans en fonction des modes d'agrégation 

```{r, date-modalite, fig.cap="(ref:date-modalite)", fig.align='center'}
# on va utiliser ggplot2 donc il faut que cela soit en tidy, au moins un peu
relation_sans_NA_tidy.dat <- gather(relation_sans_A.dat, "date_startC", "date_stopC", key = "debut_fin", value = "date")
# date de début et de fin des relation par modAgreg
date_modalite <- ggplot(relation_sans_NA_tidy.dat, aes(date, color = debut_fin)) +
    geom_freqpoly(binwidth = 50) + 
    facet_wrap(~modAgreg) +
    labs(x = "", y = "") +
    theme_bw()
# c'est du js
f <- list(
  family = "Courier New, monospace",
  size = 18,
  color = "#7f7f7f"
)
x <- list(
  title = "date (50 ans)",
  titlefont = f
)
y <- list(
  title = "décompte",
  titlefont = f
)
ggplotly(date_modalite) %>% 
    layout(xaxis = x, yaxis = y)
    
```

En plus des 210 valeurs manquantes il y `r nrow(relation_sans_A.dat[relation_sans_A.dat$DureeFact == 0,])` durées nulles (`DureeFact == 0`). Est-il possible que ces durées soit inférieures à notre grain temporelle (une année) ?

Il y a `r nrow(relation_sans_A.dat[relation_sans_A.dat$DureeFact != 0,])` durées de plus d'un an. 

le tableau \@ref(tab:modalite-duree) représente la répartition des durées nulles par modalités.La filiation descendante, le déplacement d'institution et le droit de patronnage restent dans des proportions similaires entre les deux categories (0/1) par contre l'association de prière et la possésion semble proportionnelement plus souvent représentés par des durées (notre olivier : je n'ai pas fait de chi2 ni de comparaison multiple est-ce utile/nécessaire ?).   

(ref:modalite-duree) Répartition des durées nulles (0) ou supérieures à 1 (1) par modalités

```{r, modalite-duree}
relation_sans_A.dat$modalite <- factor(relation_sans_A.dat$modalite) # on recode pour dropper les niveau du facteur absent
# une variable pour séparer ceux qui ont une durée des autres
relation_sans_A.dat$durée01 <- 0
relation_sans_A.dat$durée01[relation_sans_A.dat$DureeFact != 0] <- 1

knitr::kable(table(relation_sans_A.dat$modalite, relation_sans_A.dat$durée01), caption = "(ref:modalite-duree)") # puis un tableau
```

La figure \@ref(fig:durre-modalite) 

(ref:durre-modalite) Boites à moustaches des durées en fonction des modalités de relation

```{r, durre-modalite, fig.align='center', fig.cap="(ref:durre-modalite)"}
f <- list(
  family = "Courier New, monospace",
  size = 18,
  color = "#7f7f7f"
)

y <- list(
  title = "Durée (années)",
  titlefont = f
)
relation_duree.dat <- relation_sans_A.dat[relation_sans_A.dat$DureeFact != 0,]

plot_ly(relation_duree.dat, y = ~DureeFact, color = ~modalite, type = "box",
        text = paste(relation_duree.dat$usual_name, relation_duree.dat$modalite, relation_duree.dat$linked_implantation, sep = "\n")) %>% 
layout(yaxis = y)
```

