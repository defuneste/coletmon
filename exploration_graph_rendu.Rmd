---
title: "exploration graph"
author: "olivier"
date: "28 octobre 2019"
output: 
    bookdown::html_document2:
        theme: readable
        toc: true
        toc_float: true
        number_sections: true
        fig_caption: yes
        code_folding: hide
---


# Chargement des données et mise en forme

```{r setup, include=FALSE}
library(tidyr)
library(dplyr) # manip données
library(ggplot2) #  graphiques
library(plotly) # graphiques un peu interactif
library(igraph) # graph
library(threejs) # APi de js pour les graphs
library(sf)
``` 


## Chargement

```{r}
fait.dat <- read.csv("data/fait.txt")
implantation.dat <- read.csv("data/implantation.txt")
# on retire le num de ligne qui était passe en X
fait.dat <- subset(fait.dat, select = - X)
implantation.dat <- subset(implantation.dat, select = - X)

```

## Mise en forme

```{r}
relation.dat <- fait.dat[fait.dat$caracNew == "Relations" ,] # on ne garde que les relations
relation <- relation.dat[relation.dat$modAgreg != "A",] # on enleve les doublons
relation <- subset(relation, select =  c("idimplantation", "usual_name", "fklinked_implantation","linked_implantation_name")) # on ne garde que les noms et noms liées
# on drop les facteurs non pris en compte suite aux subset de relations
relation$usual_name <- factor(relation$usual_name)
relation$linked_implantation_name <- factor(relation$linked_implantation_name)
```


Dans un premier temps je ne vais travailler qu'avec les relations représentées par des couples noms d'implantations et noms d'implantations liées. Il s'agira par la suite de complexifier. 

# Description des relations

## Quelques chiffres à garder en tête

### Les relations directes

Cela recouvre `r nrow(relation)` relations directes car celles avec `modAgreg == A` ont été retirées (elles doublonnaient avec `modAgreg == D`). Il y a `r length(unique(relation$idimplantation))` implantations distinctes (`idimplantation`) qui sont liées à `r length(unique(relation$fklinked_implantation))` implantations liées distinctes (`fklinked_implantation`). 

Le tableau \@ref(tab:relationusualname) et le diagramme en baton \@ref(fig:relationidimplantation-bar) représentent le nombre de relations que l'on a pour chaque noms d'implantations distincts (`idimplantation`). Il y a deux implantations (Charroux, Saint-Sauveur et Cluny) qui possèdent 124 et 83 relations puis on obtient un second groupe d'implantations avec un nombre de relations contenues entre 38 et 20. Ensuite les nombre d'implantations possedant de moins en moins de relations va augmenter, presque exponentiellement pour culminer au groupe d'implantations ne possedant qu'une relation (155).


```{r, relationusualname, results="asis" }
# un tableau avec les Id et les noms
idimplant_court <- subset(implantation.dat, select = c(idimplantation, usual_name))

implantation_relation <- relation %>% 
    group_by(idimplantation) %>% # on groupe par usual name
    summarize(nb = n()) %>%  # on compte par ce group
    arrange(desc(nb)) %>% # on passe en decroissant
    left_join(idimplant_court,by = "idimplantation") # ion rajoute le nom
# une bidouille pour avoir un titre de tableau avec ref
cat("<tableau>",paste0("<caption>", "(#tab:relationusualname)", ' Nombre de relations directes par idimplantation', "</caption>"),"</tableau>", sep ="\n")
DT::datatable(implantation_relation)


```

(ref:relationidimplantation-bar) Diagramme en baton du nombre de relations directes par idimplantation 

```{r, relationidimplantation-bar, fig.cap="(ref:relationidimplantation-bar)", fig.align = 'center'}
gg_implantation_relation <- ggplot(implantation_relation) +
        geom_bar(aes(nb)) + 
        labs(x = "", y = "") +
        theme_bw()
# c'est du js
f <- list(
  family = "Courier New, monospace",
  size = 18,
  color = "#7f7f7f"
)
x <- list(
  title = "Nombre de relations par idimplantation",
  titlefont = f
)
y <- list(
  title = "décompte",
  titlefont = f
)
ggplotly(gg_implantation_relation) %>% 
    layout(xaxis = x, yaxis = y)
```


### une carte des implantations par nombre de relations directes

```{r, include=FALSE}
source("fonctions_carto.R") # on charge des fonctions de carto
# on passe implantation en sf
implantation.shp <- st_as_sf(implantation.dat[!is.na(implantation.dat$lat),], coords = c("lng", "lat"), crs = 4326)
# de wgs 84 au lambert 93
implantation.shp <- st_transform(implantation.shp, 2154) 
implantation_relation.shp <- st_sf(left_join(implantation_relation, implantation.shp, by = "idimplantation"))
diocese.shp <- diocese()
```


```{r, message = FALSE, fig.align = 'center'}

initmapview()
 mapview::mapview(diocese.shp, color = "white",  lwd = 1, # couleur et type du contour
                      col.regions = "grey",  alpha = 0.5,                  # couleur du fond et type
                      layer.name = "Diocèses" ) +
 mapview::mapview(implantation.shp, cex = 0.1, layer.name = "Implantations", col.regions = "black") +
 mapview::mapview(implantation_relation.shp, cex = "nb", layer.name = "implantations avec relations")
```

# Des graphs

## Un graph non orienté pour commencer

```{r, préparation-des-données}
 

# je prefere des caracteres donc autant garder une syntaxe V pour vertex
relation_graph <- subset(relation, select = c(idimplantation, fklinked_implantation))
relation_graph$idimplantation <-  paste0("V", relation_graph$idimplantation)
relation_graph$fklinked_implantation <- paste0("V", relation_graph$fklinked_implantation)

implantation.dat$name <- paste0("V", implantation.dat$idimplantation)

# on garde pas tout, il est important que le première colonne contienne les noms de vertex cf help(grap.data.frame)
implantationVertex.dat <- implantation.dat[,c(16,2,3,9:11)] 
graph_relation <- graph.data.frame(relation_graph, 
                                   directed = FALSE)


# le match est un peu tricky ici car utilisé pour réduire et ordonner 
implantationVertex.dat <- implantationVertex.dat[match(relation_graph$idimplantation, implantationVertex.dat$name),]

# on rajoute en décorations des atttribut au vertex
for(col_name in colnames(implantationVertex.dat)) {
  graph_relation = set_vertex_attr(graph_relation, col_name,  1:nrow(implantationVertex.dat), value=implantationVertex.dat[,col_name])
}

# on simplifie le graph # en ajoutant un poids pour le nombre de relation
E(graph_relation)$weight <- 1
# on fait le nouveau graph avec le poids 
graph_ensemble_simplify <- simplify(graph_relation, edge.attr.comb = "sum") 

```


Le graph que l'on obtient comporte des liens doubles (`r nrow(relation_graph[which_multiple(graph_relation),])`), c'est à dire que l'on peut avoir plusieurs relations entre deux noeuds (implantations). C'est logique vu que le relations et les implantations peuvent évoluer au cours du temps. C'est quelque chose que nous allons devoir observer plus en detail. Dans un premier temps, une solution est de les regrouper pour en faire un "poids", plus ce poids est importants plus ces implantations possèdent des relations (cela suppose de mettre en équivalance les relations sur le principe d'une relation = une relation).  

Plus étrange il y a une "boucle", c'est à dire une relation entre une meme implantation : 

```{r}
# on regarde à quoi elle correspond
relation.dat[relation.dat$idimplantation == 102 & relation.dat$fklinked_implantation == 102,]
```

En tenant donc compte de cette boucle et de ces `r nrow(relation_graph[which_multiple(graph_relation),])` liens multiple on obtient `r length(E(graph_ensemble_simplify)$weight)` liens. 


